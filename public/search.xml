<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用jsDelivr和Cloudflare加速Github Pages网站</title>
      <link href="/2019/09/29/jia-su-github-pages-wang-zhan/"/>
      <url>/2019/09/29/jia-su-github-pages-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="利用jsDelivr和Cloudflare加速Github-Pages网站"><a href="#利用jsDelivr和Cloudflare加速Github-Pages网站" class="headerlink" title="利用jsDelivr和Cloudflare加速Github Pages网站"></a>利用jsDelivr和Cloudflare加速Github Pages网站</h1><p>最近觉得学的东西不少，但是我从来没有记录过，最近正好因为新建了个博客，热乎劲还没过去，所以写点什么。</p><p>我比较穷，不想买个服务器，买了也浪费，同时又想写博客。还不想通过CSDN，简书之类的“广告网站”来写东西（最近发现在手机上用Chrome浏览器看简书的内容的时候会有弹屏广告，而且关不掉，遂放弃了简书）。突然想起了好久之前看过的Github Pages，于是照着网上的教程进行了梳理，最终创建了一个我还比较满意的博客。只是有一个很严重的缺陷，就是国内访问太慢了，查了很多教程，发现都是些接入国内CDN的教程，国内CDN不仅贵，而且你不备案是不能用的。对于我这样一个没啥需求的用户，还得做网站备案，太麻烦了。于是想能不能曲线救国，最终找到了一个比较有效，能提高Github Pages速度的方法，还不用花钱（可能要花点，但是不多）。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>先上效果（两个网页均是通过 <strong>清空缓存并硬性重新加载</strong> 方式来测试的）</p><p><img src="https://i.loli.net/2019/09/29/f9ij6oYm83UpadG.png" alt="这是我用的主题的作者给的示例站，直到35000ms的时候才算是正式加载完成"></p><p><img src="https://i.loli.net/2019/09/29/obNetxyrPZQ5fHR.png" alt="这是本站加载速度，8000ms的时候就基本上加载完成"></p><p>对于速度，大家可以自行测试，本站和 <a href="https://blinkfox.github.io" target="_blank" rel="noopener">blinkfox.github.io</a> 使用的是同一套模板，对方9.9s时还没跳到主页，我站8s就已经全部加载完成。那我做了什么改动呢？</p><h2 id="第一步——压缩图片"><a href="#第一步——压缩图片" class="headerlink" title="第一步——压缩图片"></a>第一步——压缩图片</h2><p>刚开始的时候没有头绪，因为不知道Github Pages能换域名。我一想，图片是显示的大头，先从压缩图片开始做起，刚好有一个公司 <a href="https://tinypng.com/" target="_blank" rel="noopener">TinyPNG</a> 提供了接口。首先我们需要打开它的官网，点击上面的 <em>Developer API</em>，输入你的名字和Email就可以获得每月500次的免费试用API的资格，你放心，这个量对于我们这种写小博客的人来说是非常够用的。申请完了之后要写个压缩的小程序。对于我来说，做个小程序还是轻而易举的，我在这里使用python来简单写写。根据官方文档说明，你首先需要下载它的库</p><blockquote><p><code>pip install --upgrade tinify</code></p></blockquote><p>然后就可以应用我这个遍历程序啦(突然发现被我删啦，重新写吧)</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> tinify<span class="token keyword">import</span> ostinify<span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token string">"YOUR_API_KEY"</span><span class="token keyword">def</span> <span class="token function">tinify_all_pic</span><span class="token punctuation">(</span>rootdir<span class="token punctuation">)</span><span class="token punctuation">:</span>    _files <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    list <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>rootdir<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rootdir<span class="token punctuation">,</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>            tinify_all_pic<span class="token punctuation">(</span>path<span class="token punctuation">)</span>        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isfile<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>            suffix <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> suffix <span class="token operator">==</span> <span class="token string">'.png'</span> <span class="token operator">or</span> suffix <span class="token operator">==</span> <span class="token string">'.jpg'</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>                source <span class="token operator">=</span> tinify<span class="token punctuation">.</span>from_file<span class="token punctuation">(</span>path<span class="token punctuation">)</span>                source<span class="token punctuation">.</span>to_file<span class="token punctuation">(</span>path<span class="token punctuation">)</span>tinify_all_pic<span class="token punctuation">(</span>r<span class="token string">"themes\hexo-theme-matery\source"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 这里是用我存放资源的一个文件夹做示范，根据你们的文件夹不同进行相应的更换</span></code></pre><p>压缩率通常在50%以上（特别是你用超过1M以上的图片的时候），这样你在加载的时候不就提高50%的加载速度了嘛😂（不是）。</p><p>这样操作之后你的加载速度可以提高至少20%以上（一些模板资源也被压缩了，有些图片没法用网页URL来代替）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 加速 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Pages </tag>
            
            <tag> 加速 </tag>
            
            <tag> jsdelivr </tag>
            
            <tag> Cloudflare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OMNET++入门教程|第1章 —— TicToc模型</title>
      <link href="/2019/09/26/omnet-ru-men-jiao-cheng-2/"/>
      <url>/2019/09/26/omnet-ru-men-jiao-cheng-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.omnetpp.org/tutorials/tictoc/part1/" target="_blank" rel="noopener">官方教程链接</a></p><h1 id="OMNET-入门教程-第1章-——-TicToc模型"><a href="#OMNET-入门教程-第1章-——-TicToc模型" class="headerlink" title="OMNET++入门教程|第1章 —— TicToc模型"></a>OMNET++入门教程|第1章 —— TicToc模型</h1><h2 id="1-模型"><a href="#1-模型" class="headerlink" title="1 模型"></a>1 模型</h2><p>首先，让我们从一个由两个节点组成的“网络”开始。节点将做一些简单的事情：其中一个节点将创建一个数据包，两个节点将继续来回传递相同的数据包。我将调用节点tic和toc。稍后我们将逐步改进这个模型，在每个步骤中来引入OMNET++特性。</p><p>以下是从零开始实现第一个模拟的步骤。</p><h2 id="2-建立项目"><a href="#2-建立项目" class="headerlink" title="2 建立项目"></a>2 建立项目</h2><p>首先打开OMNET++的主界面，在主菜单中选择 <em>File-&gt; New -&gt; OMNeT++ Project</em> </p><p><img src="https://i.loli.net/2019/09/27/xKrMTzNh4eAZtWb.jpg" alt=""><br>然后会出现这个界面<br><img src="https://i.loli.net/2019/09/27/3tzclP761W2xTNv.jpg" alt=""><br>Project name输入TT（官方直接有一个tictoc，如果输入tictoc就直接进入它的例子了，这里我们尝试从头开始写），其他的保持默认即可，点击Next（<strong>别点错成Finish</strong>），在让你选择 <em>initial content</em>时，选择 <em>Empty project</em>，然后一路Next，最后无法选择Next时选择Finish。最后的效果如图<br><img src="https://i.loli.net/2019/09/27/NUyIA9vVSc5jhfg.jpg" alt=""></p><h2 id="3-添加NED文件"><a href="#3-添加NED文件" class="headerlink" title="3 添加NED文件"></a>3 添加NED文件</h2><p>OMNeT ++使用NED文件来定义组件并将它们组装成更大的单元，例如网络。我们开始通过添加NED文件来实现我们的模型。要将文件添加到项目中，请在左侧的项目资源管理器面板中右键单击项目目录 ，然后从菜单中选择 <em>File-&gt; New -&gt; Network Description File (NED)</em>。下面的 <em>File name</em>输入tt.ned，然后点击Finish即可</p><p><img src="https://i.loli.net/2019/09/27/8GVsEzim71RcJto.png" alt=""></p><p><img src="https://i.loli.net/2019/09/27/8s9RTVca4UGNfXz.png" alt=""></p><p>然后就可以开始构建网络了，切换到 <em>Source</em> 模式，然后输入以下内容：</p><pre class=" language-cpp"><code class="language-cpp">simple Txc1<span class="token punctuation">{</span>    gates<span class="token operator">:</span>        input in<span class="token punctuation">;</span>        output out<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Two instances (tic and toc) of Txc1 connected both ways.</span><span class="token comment" spellcheck="true">// Tic and toc will pass messages to one another.</span><span class="token comment" spellcheck="true">//</span>network Tictoc1<span class="token punctuation">{</span>    submodules<span class="token operator">:</span>        tic<span class="token operator">:</span> Txc1<span class="token punctuation">;</span>        toc<span class="token operator">:</span> Txc1<span class="token punctuation">;</span>    connections<span class="token operator">:</span>        tic<span class="token punctuation">.</span>out <span class="token operator">--</span><span class="token operator">></span> <span class="token punctuation">{</span>  delay <span class="token operator">=</span> 100ms<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">--</span><span class="token operator">></span> toc<span class="token punctuation">.</span>in<span class="token punctuation">;</span>        tic<span class="token punctuation">.</span>in <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">{</span>  delay <span class="token operator">=</span> 100ms<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">&lt;</span><span class="token operator">--</span> toc<span class="token punctuation">.</span>out<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://i.loli.net/2019/09/27/1PZGJVpD4ug5jcd.png" alt=""></p><p>然后切换回 <em>Design</em> 模式，就会看到类似如下的场景</p><p><img src="https://i.loli.net/2019/09/27/Pf2wZY35xtbuicC.png" alt=""></p><p>那我们来看一下两块代码是什么意思</p><p>首先，第一块定义了一个简单模块Txc1</p><p>第二块定义了一个复合模块(类型) Tictoc1,其中包含子模块tic和toc,它们都是简单模块类型Txc1的实例。Tic的输出门(out)连接到toc的输入门(in),Toc的输出门(out)连接到tic的输入门(in) ,传输延迟均为100ms。</p><h2 id="4-添加C-文件"><a href="#4-添加C-文件" class="headerlink" title="4 添加C++文件"></a>4 添加C++文件</h2><p>现在，我们需要在C++中实现Txc1简单模块的功能。从项目的菜单中选择 <em>File -&gt; Other</em>,然后在下面的选择栏里选择 <em>C/C++ -&gt; Source File</em> ，创建一个名为txc1.cc的文件，并输入以下内容：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;omnetpp.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> omnetpp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Derive the Txc1 class from cSimpleModule. In the Tictoc1 network, * both the `tic' and `toc' modules are Txc1 objects, created by OMNeT++ * at the beginning of the simulation. */</span><span class="token keyword">class</span> <span class="token class-name">Txc1</span> <span class="token operator">:</span> <span class="token keyword">public</span> cSimpleModule<span class="token punctuation">{</span>  <span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// The following redefined virtual function holds the algorithm.</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>cMessage <span class="token operator">*</span>msg<span class="token punctuation">)</span> override<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// The module class needs to be registered with OMNeT++</span><span class="token function">Define_Module</span><span class="token punctuation">(</span>Txc1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> Txc1<span class="token operator">::</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Initialize is called at the beginning of the simulation.</span>    <span class="token comment" spellcheck="true">// To bootstrap the tic-toc-tic-toc process, one of the modules needs</span>    <span class="token comment" spellcheck="true">// to send the first message. Let this be `tic'.</span>    <span class="token comment" spellcheck="true">// Am I Tic or Toc?</span>    <span class="token comment" spellcheck="true">//仿真初始化，由节点tic发出第一条消息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"tic"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// create and send first message on gate "out". "tictocMsg" is an</span>        <span class="token comment" spellcheck="true">// arbitrary string which will be the name of the message object.</span>        <span class="token comment" spellcheck="true">//创建输出门“out”发出第一条消息"tictocMsg"，不过发的啥这里并不关心</span>        cMessage <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">cMessage</span><span class="token punctuation">(</span><span class="token string">"tictocMsg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> Txc1<span class="token operator">::</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>cMessage <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// The handleMessage() method is called whenever a message arrives</span>    <span class="token comment" spellcheck="true">// at the module. Here, we just send it to the other module, through</span>    <span class="token comment" spellcheck="true">// gate `out'. Because both `tic' and `toc' does the same, the message</span>    <span class="token comment" spellcheck="true">// will bounce between the two.</span>    <span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// send out the message</span><span class="token punctuation">}</span></code></pre><p><img src="https://i.loli.net/2019/09/27/bOmDvLfCaF3KBlI.png" alt=""><br><img src="https://i.loli.net/2019/09/27/ItZmzQnHFPgYpE6.png" alt=""><br><img src="https://i.loli.net/2019/09/27/5gGz376LDIKbBaX.png" alt=""></p><p>根据 NED 文件中定义的字模块关系，<em>initialize()</em> 函数中节点 tic 从输出门“out”发出的消息经过 100ms 传输延迟必然到达节点 toc的输入门“tic”，并触发其 <em>handleMessage()</em> 函数。 不难看出该消息就像一只乒乓球，将在两个节点间来回传输。不过请注意，此模拟中没有内置停止条件：它将永远持续。你可以在IDE上让它停止运行。</p><h2 id="5-配置omn​​etpp-ini"><a href="#5-配置omn​​etpp-ini" class="headerlink" title="5 配置omn​​etpp.ini"></a>5 配置omn​​etpp.ini</h2><p>为了能够运行模拟，我们需要创建<code>omnetpp.ini</code>文件。<code>omnetpp.ini</code>告诉仿真程序要模拟哪个网络（因为ned文件可能包含多个网络），可以将参数传递给模型，显式指定随机数生成器的种子等。</p><p>从菜单里选择 <em>File -&gt; New -&gt; Initialization file (INI)</em> 创建<code>omnetpp.ini</code>文件。新文件将在IniFile编辑器中打开。作为ned编辑器，inifile编辑器还有两种模式，<em>Form</em>和<em>Source</em>，用于编辑相同的内容。前者更适合配置仿真内核，后者更适合输入模块参数。</p><p>现在，只需切换到 <em>Source</em> 模式并输入以下内容：</p><pre><code>[General]network = Tictoc1</code></pre><p><img src="https://i.loli.net/2019/09/27/ZHyoesIrKWSPMjt.png" alt=""><br><img src="https://i.loli.net/2019/09/27/hHW5ISEtoTdCa3v.png" alt=""></p><p>点击 <em>Run</em> 或使用快捷键 <code>Ctrl+F11</code> 运行，可能弹出两个提示框，不用管他，直接运行即可，最后会弹出一个窗口来显示仿真结果，效果如图。</p><p><img src="https://i.loli.net/2019/09/27/b8Bhryno1U5luvL.gif" alt=""></p><p>下一节我会着重讲一下模拟的过程。就说到这里吧，有什么问题大家可以通过评论区联系我。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OMNET++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OMNET++ </tag>
            
            <tag> TicToc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OMNET++入门教程|第0章——安装</title>
      <link href="/2019/09/24/omnet-ru-men-jiao-cheng/"/>
      <url>/2019/09/24/omnet-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="OMNET-入门教程-第0章——安装"><a href="#OMNET-入门教程-第0章——安装" class="headerlink" title="OMNET++入门教程|第0章——安装"></a>OMNET++入门教程|第0章——安装</h1><p>最近需要学的东西不少，于是准备写点什么。正好最近在研究通信协议方面的知识，老师建议学一学OMNET++，正好网上的相关资料比较少，我自己也写点什么。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>首先第一步去官网下载，打开 <a href="https://omnetpp.org/" target="_blank" rel="noopener">OMNET++的官网</a>，选择右上角的Download，选择合适的版本来进行下载，比如我就是Windows 10 64位，就需要下载Windows版本<br><img src="https://i.loli.net/2019/09/26/4MKnyYdFTQtv2zO.jpg" alt="根据自己的版本进行安装"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完成后是一个压缩包，在合适的目录解压后，第一次遇到下载软件的压缩包里面没有安装包，感觉还是束手无策的，赶紧上网查了查，终于知道了具体怎么安装，首先先给一张图片<br><img src="https://pic4.zhimg.com/81877348c76aada1e5db9e97cfb3733b_r.jpg" alt="安装过程"><br>这个图片写的已经很清楚了，首先双击运行<code>mingwenv.cmd</code>，然后文件会自动解压，按照其他网站的理论，可能你需要先安装G++之类的编译器，但是我没有遇到这个情况，如果有人遇到什么情况也可以在评论区留言给我。</p><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>第二步就是输入<code>./configure</code>这个命令，它会自动执行，最后出现 <strong>Good！</strong> 之类的话，说明这一步成功了。然后接着输入<code>make</code>命令来进行编译，时间非常长，耐心等待，等屏幕上输出 <strong>Now you can type “omnetpp” to start the IDE</strong> 字样，说明安装完成了，可以直接输入<code>omnetpp</code>打开IDE。然后因为我比较懒，相信它应该有实体的exe，然后就找了起来。这个时候我其实下意识的进入<code>./bin</code>这个文件夹，因为这个文件夹通常是用来存放二进制文件的，但是发现里面没有IDE，是因为其实这个软件没有IDE应该也能运行（我想不出一个仿真软件在没有IDE的情况下是怎么仿真的），真正的IDE是在<code>./ide</code>这个文件夹当中的，这个时候可以建立一个快捷方式放在根目录，更方便。就不用每次通过进命令行输入<code>omnetpp</code>进入IDE了。</p><p><img src="https://i.loli.net/2019/09/26/95I1kyYfN7pJTCO.jpg" alt="omnet++主界面"></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>具体安装过程虽然不如安装包点点简单，但是还是蛮简单的，但是我没有在官方文档找到相关教程，可能还是有点欠缺吧。就说到这里吧，有什么问题大家可以通过评论区联系我，或者直接通过右面的Daovoice联系我（最好是评论区，那个我可能不看），下次我将介绍一个简单的例子来入门OMNET++。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OMNET++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OMNET++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
