<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cloudflare Worker+jsproxy实现浏览器代理访问谷歌</title>
      <link href="/2019/11/04/cloudflare-worker-jsproxy/"/>
      <url>/2019/11/04/cloudflare-worker-jsproxy/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="Cloudflare-Worker-jsproxy实现浏览器代理访问谷歌"><a href="#Cloudflare-Worker-jsproxy实现浏览器代理访问谷歌" class="headerlink" title="Cloudflare Worker+jsproxy实现浏览器代理访问谷歌"></a>Cloudflare Worker+jsproxy实现浏览器代理访问谷歌</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>CloudFlare Worker</code> 是 CloudFlare 的边缘计算服务。开发者可通过 JavaScript 对 CDN 进行编程，从而能灵活处理 HTTP 请求。这使得很多任务可在 CDN 上完成，无需自己的服务器参与。使用jsproxy技术就可以轻松进行前端代理功能，同时没有任何费用。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>首页：<a href="https://workers.cloudflare.com" target="_blank" rel="noopener">https://workers.cloudflare.com</a></p><p>注册，登陆，<code>Start building</code>，取一个子域名，<code>Create a Worker</code>。</p><p>复制 <a href="https://raw.githubusercontent.com/EtherDream/jsproxy/master/cf-worker/index.js" target="_blank" rel="noopener">index.js</a> 到左侧代码框，<code>Save and deploy</code>。如果正常，右侧应显示首页。</p><p>收藏地址框中的 <code>https://xxxx.子域名.workers.dev</code>，以后可直接访问。</p><p>我进行了美化，效果图如下：</p><p><img src="https://i.loli.net/2019/11/12/qLJ5u1XRjr7EFCV.png" alt></p><h2 id="计费"><a href="#计费" class="headerlink" title="计费"></a>计费</h2><p>后退到 <code>overview</code> 页面可参看使用情况。免费版每天有 10 万次免费请求，对于个人通常足够。</p><p>如果不够用，可注册多个 Worker，在 <code>conf.js</code> 中配置多线路负载均衡。或者升级到 $5 的高级版本，每月可用 1000 万次请求（超出部分 $0.5/百万次请求）。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>默认情况下，静态资源从 <code>https://etherdream.github.io/jsproxy</code> 反向代理，可通过代码中 <code>ASSET_URL</code> 配置，从而可使用自定义的 <code>conf.js</code> 配置。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><ul><li><p>WebSocket 代理尚未实现</p></li><li><p>外链限制尚未实现</p></li><li><p>未充分测试，以后再完善</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script></body></html>]]></content>
      
      
      <categories>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsproxy </tag>
            
            <tag> 前端代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B站2019秋招编程题</title>
      <link href="/2019/10/23/2019bilibili/"/>
      <url>/2019/10/23/2019bilibili/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>B站在牛客网（ <a href="https://www.nowcoder.com/test/16519291/summary" target="_blank" rel="noopener">https://www.nowcoder.com/test/16519291/summary</a> ）<br>上发了一套自己秋招的编程题，恰好今年被老师忽悠着去再参加一次蓝桥杯（我参加C++组，所以下面的题都是用C++做的，没用我熟悉的python），虽然那个比赛很水，但是还是要提高我的编程能力才是。于是准备做点题练习下，B站这个题挺好，题目很新颖（仅限题目描述），不过内容和那个比赛一样水，所以给大家解析下。</p><h1 id="1-扭蛋机-answer"><a href="#1-扭蛋机-answer" class="headerlink" title="1.扭蛋机 answer"></a>1.扭蛋机 <a href="https://www.nowcoder.com/questionTerminal/9d26441a396242a9a0f7d2106fc130c7" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：32768K</p></blockquote><p>22娘和33娘接到了小电视君的扭蛋任务：<br>一共有两台扭蛋机，编号分别为扭蛋机2号和扭蛋机3号，22娘使用扭蛋机2号，33娘使用扭蛋机3号。<br>扭蛋机都不需要投币，但有一项特殊能力：<br>扭蛋机2号：如果塞x（x范围为>=0正整数）个扭蛋进去，然后就可以扭到2x+1个<br>扭蛋机3号：如果塞x（x范围为>=0正整数）个扭蛋进去，然后就可以扭到2x+2个<br>22娘和33娘手中没有扭蛋，需要你帮她们设计一个方案，两人“轮流扭”（谁先开始不限，扭到的蛋可以交给对方使用），用“最少”的次数，使她们能够最后恰好扭到N个交给小电视君。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>输入一个正整数，表示小电视君需要的N个扭蛋。</p></blockquote><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>输出一个字符串，每个字符表示扭蛋机，字符只能包含”2”和”3”。</p></blockquote><h3 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>10</p></blockquote><h3 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>233</p></blockquote><p>思路有两种，一种是BFS，一种是通过二叉树（其实你看到2x+1和2x+2就差不多知道了），因为这个题是这样的：</p><p><img src="https://i0.hdslb.com/bfs/article/b3688094c946e80621c9aeddea1af65114bcc717.png" alt></p><p>可以看到，n是奇数都是最后22扭的，n是偶数都是最后33扭的，那么我们就可以倒着找出最终的顺序。找到下一层之后返回上一层，如果是奇数就是(n-1)/2,偶数就是(n-2)/2，具体可自行验证。给出C++的示例代码：</p><p><img src="https://i0.hdslb.com/bfs/article/3231b98c148b9c98556239e35551d0267723bad2.png" alt></p><h1 id="2-脸滚键盘-answer"><a href="#2-脸滚键盘-answer" class="headerlink" title="2.脸滚键盘 answer"></a>2.脸滚键盘 <a href="https://www.nowcoder.com/questionTerminal/2a3dc06f337d4a2ba41d25c688f95e2f" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：32768K</p></blockquote><p><a href="https://www.bilibili.com/av394281" target="_blank" rel="noopener">av394281</a> 中，充满威严的蕾米莉亚大小姐因为触犯某条禁忌，被隙间妖怪八云紫（紫m……èi）按住头在键盘上滚动。<br>同样在弹幕里乱刷梗被紫姐姐做成罪袋的你被指派找到大小姐脸滚键盘打出的一行字中的第 <code>k</code> 个仅出现一次的字。<br>(为简化问题，大小姐没有滚出 ascii 字符集以外的字)</p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>每个输入都有若干行，每行的第一个数字为<code>k</code>，表示求第<code>k</code>个仅出现一次的字。然后间隔一个半角空格，之后直到行尾的所有字符表示大小姐滚出的字符串<code>S</code>。</p></blockquote><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>输出的每一行对应输入的每一行的答案，如果无解，输出字符串<code>Myon~</code><br><br>(请不要输出多余的空行）<br><br>为了方便评测，如果答案存在且为c，请输出[c]</p></blockquote><h3 id="输入例子1-1"><a href="#输入例子1-1" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>2 misakamikotodaisuki<br>3 !bakabaka~ bakabaka~ 1~2~9!<br>3 3.1415926535897932384626433832795028841971693993751o582097494459211451488946419191919l91919hmmhmmahhhhhhhhhh<br>7 <a href="http://www.bilibili.com/av170001\" target="_blank" rel="noopener">www.bilibili.com/av170001\</a><br>1 111</p></blockquote><h3 id="输出例子1-1"><a href="#输出例子1-1" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>[d]<br>[9]<br>[l]<br>[7]<br>Myon~</p></blockquote><p>这个题有几种思路，最简单的还是使用映射(map)，让出现的每个字符对应到0上。扫描整个字符串，如果碰到一个字符，就让他对应的数+1，同时记录每个字符出现的顺序。然后扫描记录的顺序，找到第k个对应数是1的字符。但是我们看到题目说的是不超过ASCII，所以直接用ASCII来映射就好了，给出示例C++代码：<br><img src="https://i0.hdslb.com/bfs/article/d434d8a0a72d5be696509fd514a3f559c44d1e4a.png" alt></p><h1 id="3-简单表达式计算-answer"><a href="#3-简单表达式计算-answer" class="headerlink" title="3.简单表达式计算 answer"></a>3.简单表达式计算 <a href="https://www.nowcoder.com/questionTerminal/6221faa383fc49f1b10dffcb62c866bf" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：32768K</p></blockquote><p>给定一个合法的表达式字符串，其中只包含非负整数、加法、减法以及乘法符号（不会有括号），例如7+3*4*5+2+4-3-1，请写程序计算该表达式的结果并输出；</p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>输入有多行，每行是一个表达式，输入以END作为结束</p></blockquote><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>每行表达式的计算结果</p></blockquote><h3 id="输入例子1-2"><a href="#输入例子1-2" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>7+3*4*5+2+4-3-1<br>2-3*1<br>END</p></blockquote><h3 id="输出例子1-2"><a href="#输出例子1-2" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>69<br>-1</p></blockquote><h1 id="4-小A最多会新认识的多少人-answer"><a href="#4-小A最多会新认识的多少人-answer" class="headerlink" title="4.小A最多会新认识的多少人 answer"></a>4.小A最多会新认识的多少人 <a href="https://www.nowcoder.com/questionTerminal/1fe6c3136d2a45fa8ef555b459b6dd26" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：32768K</p></blockquote><p>小A参加了一个n人的活动，每个人都有一个唯一编号<code>i</code>(<code>i>=0 & i<n</code>)，其中<code>m</code>对相互认识，在活动中两个人可以通过互相都认识的一个人介绍认识。现在问活动结束后，小A最多会认识多少人？</p><h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>第一行聚会的人数：n（n>=3 & n<10000）；<br>第二行小A的编号: ai（ai >= 0 & ai < n)；<br>第三互相认识的数目: m（m>=1 & m<br>< n(n-1)/2）；<br>第4到m+3行为互相认识的对，以’,’分割的编号。</p></blockquote><h3 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>输出小A最多会新认识的多少人？</p></blockquote><h3 id="输入例子1-3"><a href="#输入例子1-3" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>7<br>5<br>6<br>1,0<br>3,1<br>4,1<br>5,3<br>6,1<br>6,5</p></blockquote><h3 id="输出例子1-3"><a href="#输出例子1-3" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>3</p></blockquote><p>这个题很明显的并查集，但是据其他人说用邻接表+BFS也能做，但是这里我就不尝试了，给出并查集（最后要记得减去小A本来就认识的人）的C++示例代码：</p><p><img src="https://i0.hdslb.com/bfs/article/c3620b6cb4835cda3b98a43a1e3cbbfc8126d40e.png" alt></p><h1 id="5-山寨金闪闪-answer"><a href="#5-山寨金闪闪-answer" class="headerlink" title="5.山寨金闪闪 answer"></a>5.山寨金闪闪 <a href="https://www.nowcoder.com/questionTerminal/9363dcb83ca44c61a2c1a8f65aa722b8" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：3秒<br>空间限制：262144K</p></blockquote><p>金闪闪死后，红A拿到了王之财宝，里面有n个武器，长度各不相同。红A发现，拿其中三件武器首尾相接，组成一个三角形，进行召唤仪式，就可以召唤出一个山寨金闪闪。（例如，三件武器长度为10、15、20，可以召唤成功。若长度为10、11、30，首尾相接无法组成三角形，召唤失败。）红A于是开了一个金闪闪专卖店。他把王之财宝排成一排，每个客人会随机抽取到一个区间[l,r],客人可以选取区间里的三件武器进行召唤（客人都很聪慧，如果能找出来合适的武器，一定不会放过）。召唤结束后，客人要把武器原样放回去。m个客人光顾以后，红A害怕过多的金闪闪愉悦太多男人，于是找到了你，希望你帮他统计出有多少山寨金闪闪被召唤出来。</p><h3 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>第一行武器数量:n <= 1*10^7<br>第二行空格分隔的n个int，表示每件武器的长度。<br>第三行顾客数量：m <= 1*10^6<br>后面m行，每行两个int l，r，表示每个客人被分配到的区间。（l<r）</p></blockquote><h3 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>山寨金闪闪数量。</p></blockquote><h3 id="输入例子1-4"><a href="#输入例子1-4" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>5<br>1 10 100 95 101<br>4<br>1 3<br>2 4<br>2 5<br>3 5</p></blockquote><h3 id="输出例子1-4"><a href="#输出例子1-4" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>3</p></blockquote><p>我知道这是《Fate》系列作品的衍生题目，我不玩游戏，但是咱也知道金闪闪是男的，为什么偷♂税男人啦。不过这个题很有说头，思路可以分为这几步：</p><p>1，首先，判断三个正整数a,b,c是否能组成三角形，判断方法是：将abc升序排列，然后如果a+b>c,则可以构成三角形。其次，判断一个区间[L,R]内是否能找到三个数使其构成三角形，可以将这R-L+1个元素取出并排序，然后从前往后三个三个判断。查询每次区间长度都在1~1e7之间，当然不能每次都暴力找，不然有1e6次查询，时间复杂度肯定爆炸，那么怎么处理呢？实际上，如果数一多，是非常容易构成三角形的，如果要刚好卡到边界，刚好不能构造成三角形（a+b==c），则要构造这样的数据：1，1，2，3，5，8……。<br>巧了，其实就是斐波那契数列，题目的数据给出的数据在int范围内，然后我们发现大概在40多项的时候就不能构造出全都不满足构成三角形的数据了，下面是打表的出的结果。</p><p><img src="https://i0.hdslb.com/bfs/article/b0c8293b0b7cf2342bf718d6688d72b63a629ee2.png" alt><br>int 的范围最大是2的32次方，也就是4294967296，到48项就超了，所以区间超过47必出金闪闪</p><p>所以，只要在给出的区间长度较大的，一定能构成三角形，区间长度较小的，则可以存下来排序后判断，下面给出C++示例代码：</p><p><img src="https://i0.hdslb.com/bfs/article/1d40fc7c91688baa999c7dc02c3de95f02acfeb6.png" alt></p><p>作者：高玩梁<br><a href="https://www.bilibili.com/read/cv3831139" target="_blank" rel="noopener">https://www.bilibili.com/read/cv3831139</a><br>出处： bilibili</p><h1 id="6-比较两个版本字符串version1和version2-answer"><a href="#6-比较两个版本字符串version1和version2-answer" class="headerlink" title="6.比较两个版本字符串version1和version2 answer"></a>6.比较两个版本字符串version1和version2 <a href="https://www.nowcoder.com/questionTerminal/521049ca23f147d698e1cff923c3262a" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：32768K</p></blockquote><p>如果version1 > version2 返回1，如果 version1 < version2 返回-1，不然返回0.</p><p>输入的version字符串非空，只包含数字和字符.。.字符不代表通常意义上的小数点，只是用来区分数字序列。例如字符串2.5并不代表二点五，只是代表版本是第一级版本号是2，第二级版本号是5.</p><h3 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>两个字符串，用空格分割。<br>每个字符串为一个version字符串，非空，只包含数字和字符.</p></blockquote><h3 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>只能输出1, -1，或0</p></blockquote><h3 id="输入例子1-5"><a href="#输入例子1-5" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>0.1 1.1</p></blockquote><h3 id="输出例子1-5"><a href="#输出例子1-5" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>-1</p></blockquote><h1 id="7-精灵鼠从入口到出口的最少减少速度-answer"><a href="#7-精灵鼠从入口到出口的最少减少速度-answer" class="headerlink" title="7.精灵鼠从入口到出口的最少减少速度 answer"></a>7.精灵鼠从入口到出口的最少减少速度 <a href="https://www.nowcoder.com/questionTerminal/6171d3a8748248248c21a3c8f330396d" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：2秒<br>空间限制：131072K</p></blockquote><p>猛兽侠中精灵鼠在利剑飞船的追逐下逃到一个n*n的建筑群中，精灵鼠从（0,0）的位置进入建筑群，建筑群的出口位置为（n-1,n-1），建筑群的每个位置都有阻碍，每个位置上都会相当于给了精灵鼠一个固定值减速，因为精灵鼠正在逃命所以不能回头只能向前或者向下逃跑，现在问精灵鼠最少在减速多少的情况下逃出迷宫？</p><h3 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>第一行迷宫的大小: n >=2 & n <= 10000；<br>第2到n+1行，每行输入为以’,’分割的该位置的减速,减速f >=1 & f < 10。</p></blockquote><h3 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>精灵鼠从入口到出口的最少减少速度？</p></blockquote><h3 id="输入例子1-6"><a href="#输入例子1-6" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>3<br>5,5,7<br>6,7,8<br>2,2,4</p></blockquote><h3 id="输出例子1-6"><a href="#输出例子1-6" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>19</p></blockquote><h1 id="8-顺时针打印数字矩阵-answer"><a href="#8-顺时针打印数字矩阵-answer" class="headerlink" title="8.顺时针打印数字矩阵 answer"></a>8.顺时针打印数字矩阵 <a href="https://www.nowcoder.com/questionTerminal/ce0c22a435114108bd9acc75f81b5802" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：32768K</p></blockquote><p>给定一个数字矩阵，请设计一个算法从左上角开始顺时针打印矩阵元素</p><h3 id="输入描述-7"><a href="#输入描述-7" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>输入第一行是两个数字，分别代表行数M和列数N；接下来是M行，每行N个数字，表示这个矩阵的所有元素；当读到M=-1，N=-1时，输入终止。</p></blockquote><h3 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>请按逗号分割顺时针打印矩阵元素（注意最后一个元素末尾不要有逗号！例如输出“1，2，3”，而不是“1，2，<br>3，”），每个矩阵输出完成后记得换行</p></blockquote><h3 id="输入例子1-7"><a href="#输入例子1-7" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>3 3<br>1 2 3<br>4 5 6<br>7 8 9<br>-1 -1</p></blockquote><h3 id="输出例子1-7"><a href="#输出例子1-7" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>1,2,3,6,9,8,7,4,5</p></blockquote><h1 id="9-写一段程序判断IP字符串是否属于内网IP-answer"><a href="#9-写一段程序判断IP字符串是否属于内网IP-answer" class="headerlink" title="9.写一段程序判断IP字符串是否属于内网IP answer"></a>9.写一段程序判断IP字符串是否属于内网IP <a href="https://www.nowcoder.com/questionTerminal/80ce674313ff43af9d7ac7a41ae21527" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：32768K</p></blockquote><p>从业 666 年的 BILIBILI 网络安全工程师 KindMo 最近很困惑，公司有一个业务总是受到 SSRF 攻击。请帮他写一个程序，判断输入的字符串是否属于内网IP，用于防御该漏洞。<br>我们知道常见的内网IP有，127.0.0.1，192.168.0.1 等。</p><h3 id="输入描述-8"><a href="#输入描述-8" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>每次输入仅包含一个IP字符串，即一个测试样例</p></blockquote><h3 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>对于每个测试实例输出整数1或0，1代表True，即输入属于内网IP，0代表False，即输入不属于内网IP或不是IP字符串。</p></blockquote><h3 id="输入例子1-8"><a href="#输入例子1-8" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>42.96.146.169</p></blockquote><h3 id="输出例子1-8"><a href="#输出例子1-8" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>0</p></blockquote><h1 id="10-给定一个整数数组-判断其中是否有3个数和为N-answer"><a href="#10-给定一个整数数组-判断其中是否有3个数和为N-answer" class="headerlink" title="10.给定一个整数数组,判断其中是否有3个数和为N answer"></a>10.给定一个整数数组,判断其中是否有3个数和为N <a href="https://www.nowcoder.com/questionTerminal/b69c933c28164cbd8852820c16556a84" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：131072K</p></blockquote><p>给定一个整数数组,判断其中是否有3个数和为N</p><h3 id="输入描述-9"><a href="#输入描述-9" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>输入为一行<br>逗号前为一个整数数组，每个元素间用空格隔开；逗号后为N</p></blockquote><h3 id="输出描述-9"><a href="#输出描述-9" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>输出bool值<br>True表示存在3个和为N的数<br>False表示不存在3个和为N的数\</p></blockquote><h3 id="输入例子1-9"><a href="#输入例子1-9" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>1 2 3 4 5,10</p></blockquote><h3 id="输出例子1-9"><a href="#输出例子1-9" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>True</p></blockquote><h1 id="11-实现一个HTML语法检查器-answer"><a href="#11-实现一个HTML语法检查器-answer" class="headerlink" title="11.实现一个HTML语法检查器 answer"></a>11.实现一个HTML语法检查器 <a href="https://www.nowcoder.com/questionTerminal/bbe2e0eb156446fd9a8de997e9189fe9" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：32768K</p></blockquote><p>实现一个HTML语法检查器。HTML语法规则简化如下：标签必须闭合，可以由开始和结束两个标签闭合，如<code><div></div></code>，也可以自闭合，<br>如<code><div /></code><br>标签可以嵌套如<code><div><a></a></div></code>或者 <code><div><a/></div></code>，但是标签不能交叉：<code><div><a></div></a></code>是不允许的标签里可以有属性<br>如<code><div id="a<1"></div></code><br>属性的规则是name=”任意非引号字符”，多属性声明之间必须有空格，属性声明不符合规则时，整段HTML都算语法错误<br>输入文本只会出现字母a-z和<>”=<br>请用任意语言实现一个HTML语法检查器函数，有语法错误返回1，没有语法错误返回0</p><h3 id="输入描述-10"><a href="#输入描述-10" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>一行，一个HTML字符串</p></blockquote><h3 id="输出描述-10"><a href="#输出描述-10" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>有语法错误返回1，没有语法错误返回0</p></blockquote><h1 id="12-孙悟空的徒弟-answer"><a href="#12-孙悟空的徒弟-answer" class="headerlink" title="12.孙悟空的徒弟 answer"></a>12.孙悟空的徒弟 <a href="https://www.nowcoder.com/questionTerminal/7b841a840db64f5ebec77f6ee7e307e2" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：3秒<br>空间限制：131072K</p></blockquote><p>打败魔人布欧以后，孙悟空收了n个徒弟，每个徒弟战斗力各不相同。他教导所有的徒弟和体术，合体后战斗力为原战斗力相乘。任何两个徒弟都可以合体，所以一共有n*(n-1)/2种合体徒弟。有一天，他想考验一下孙悟天战斗力如何，希望在所有n*(n-1)/2种合体徒弟中选择战斗力第k高的，与孙悟天对战。可是孙悟空徒弟太多了，他已然懵逼，于是找到了你，请你帮他找到对的人。</p><h3 id="输入描述-11"><a href="#输入描述-11" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>第一行两个int。徒弟数量：n <= 1*10^6；战斗力排名:k <= n*(n-1)/2<br>第二行空格分隔n个int，表示每个徒弟的战斗力。</p></blockquote><h3 id="输出描述-11"><a href="#输出描述-11" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>战斗力排名k的合体徒弟战斗力。</p></blockquote><h3 id="输入例子1-10"><a href="#输入例子1-10" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>5 2<br>1 3 4 5 9</p></blockquote><h3 id="输出例子1-10"><a href="#输出例子1-10" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>36</p></blockquote><h1 id="13-翻转链表-answer"><a href="#13-翻转链表-answer" class="headerlink" title="13.翻转链表 answer"></a>13.翻转链表 <a href="https://www.nowcoder.com/questionTerminal/f350f14cd22c41aabfa7e54a1b8e8825" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：32768K</p></blockquote><p>对于一个链表 L: L0→L1→…→Ln-1→Ln,<br>将其翻转成 L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>输入是一串数字，请将其转换成单链表格式之后，再进行操作</p><h3 id="输入描述-12"><a href="#输入描述-12" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>一串数字，用逗号分隔</p></blockquote><h3 id="输出描述-12"><a href="#输出描述-12" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>一串数字，用逗号分隔</p></blockquote><h3 id="输入例子1-11"><a href="#输入例子1-11" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>1,2,3,4,5</p></blockquote><h3 id="输出例子1-11"><a href="#输出例子1-11" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>1,5,2,4,3</p></blockquote><h1 id="14-ん…红茶？answer"><a href="#14-ん…红茶？answer" class="headerlink" title="14.ん…红茶？answer"></a>14.ん…红茶？<a href="https://www.nowcoder.com/questionTerminal/14a045880df44cf79626f079bd9f07f1" target="_blank" rel="noopener">answer</a></h1><blockquote><p>时间限制：1秒<br>空间限制：131072K</p></blockquote><p>高贵的蕾米莉亚大小姐每天需要饮用定量 B 型血的红茶以保持威严，并且要分两杯在不同时段饮用。<br>女仆长十六夜咲夜每天可以制作很多杯不同剂量 B 型血的红茶供蕾米莉亚大小姐饮用。<br>某日，你和天才妖精琪露诺偷偷潜入红魔馆被咲夜抓住，要求在今日份的红茶中挑出所有满足大小姐要求的茶杯，否则……</p><h3 id="输入描述-13"><a href="#输入描述-13" class="headerlink" title="输入描述:"></a>输入描述:</h3><blockquote><p>每个样例有三行输入，第一行输入表示茶杯个数，第二行输入表示每份茶杯里的 B 型血剂量，第三行表示大小姐今天的定量</p></blockquote><h3 id="输出描述-13"><a href="#输出描述-13" class="headerlink" title="输出描述:"></a>输出描述:</h3><blockquote><p>对每一个样例，输出所有可能的搭配方案，如果有多种方案，请按每个方案的第一杯 B 型血剂量的大小升序排列。<br>如果无法找到任何一种满足大小姐的方案，输出”NO”(不包括引号)并换行。</p></blockquote><h3 id="输入例子1-12"><a href="#输入例子1-12" class="headerlink" title="输入例子1:"></a>输入例子1:</h3><blockquote><p>7<br>2 4 6 1 3 5 7<br>7</p></blockquote><h3 id="输出例子1-12"><a href="#输出例子1-12" class="headerlink" title="输出例子1:"></a>输出例子1:</h3><blockquote><p>1 6<br>2 5<br>3 4</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哔哩哔哩 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高大上博客制作教程</title>
      <link href="/2019/10/05/blog-jiao-cheng/"/>
      <url>/2019/10/05/blog-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="高大上博客制作教程"><a href="#高大上博客制作教程" class="headerlink" title="高大上博客制作教程"></a>高大上博客制作教程</h1><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>首先下载稳定版<a href="https://nodejs.org/dist/v9.11.1/node-v9.11.1-x64.msi" target="_blank" rel="noopener">Node.js</a>，我这里给的是64位的。</p><p>安装选项全部默认，一路点击<code>Next</code>。</p><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><h2 id="添加国内镜像源"><a href="#添加国内镜像源" class="headerlink" title="添加国内镜像源"></a>添加国内镜像源</h2><p>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org</code></pre><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">[下载地址]</a>。</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p><h2 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h2><p>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>，新建一个项目，输入自己的项目名字，后面一定要加<code>.github.io</code>后缀。<strong>名称一定要和你的github名字完全一样，比如你github名字叫<code>abc</code>，那么仓库名字一定要是<code>abc.github.io</code>。</strong><br>然后项目就建成了，点击<code>Settings</code>，向下拉到最后有个<code>GitHub Pages</code>，点击<code>Choose a theme</code>选择一个主题。然后等一会儿，再回到<code>GitHub Pages</code>，在地址栏输入<code>你的用户名.github.io</code>就能看到你的主页了。<br>具体可以看我的<a href="https://www.bilibili.com/video/av70212514" target="_blank" rel="noopener">B站视频</a></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p><p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g && hexo s</code>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，就可以看到我们的博客啦</p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h2 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h2><p>首先右键打开git bash，然后输入下面命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"你的用户名"</span><span class="token function">git</span> config --global user.email <span class="token string">"你注册时用的邮箱"</span></code></pre><p>用户名和邮箱根据你注册github的信息自行修改。</p><p>然后生成密钥SSH key：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"你注册时用的邮箱"</span></code></pre><p><strong>问enter file in which….时输入 ./ssh (不要忘了最前面的点)</strong></p><p>打开<a href="https://github.com" target="_blank" rel="noopener">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>打开文件夹下的ssh.pub文件，复制到key里即可</p><p>输入<code>ssh -T git@github.com -i ./ssh</code>，如果出现你的用户名，那就成功了。</p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><pre class=" language-bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repository: https://github.com/gaowanliang/gaowanliang.github.io  branch: master</code></pre><p>repository修改为你自己的github项目地址。</p><h2 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h2><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post "文章标题"</code>，新建一篇文章。</p><p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p><p>以我的Cloudflare为例，如下图所示，添加这条解析记录：<br><img src="https://i.loli.net/2019/10/06/CHx8L6cAZJ92RQ3.png" alt></p><p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：<br><img src="https://i.loli.net/2019/10/06/5v7clsJBFQM9g1a.png" alt></p><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\study\program\blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。</p><h2 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h2><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git checkout hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p><h2 id="下载我弄好的主题包"><a href="#下载我弄好的主题包" class="headerlink" title="下载我弄好的主题包"></a>下载我弄好的主题包</h2><p>大家也可以先用上文hexo安装方法安装完hexo，然后直接<a href="https://cdn.jsdelivr.net/gh/gaowanliang/gitment-store/hexo-theme-matery.zip" target="_blank" rel="noopener">下载这个文件</a>，放到theme文件夹里，这是我修改完的基本没bug的定制化的博客，且用了<a href="http://www.gwl6.me/2019/09/30/jia-su-github-pages-wang-zhan/">这篇博客</a>里说的加速方式，就不用你自己搞了，就可以直接拿来用啦。</p><h2 id="其他定制选项"><a href="#其他定制选项" class="headerlink" title="其他定制选项"></a>其他定制选项</h2><p>可以看主题包作者写的<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">这个</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script></body></html>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用jsDelivr和Cloudflare免备案加速Github Pages网站</title>
      <link href="/2019/09/30/jia-su-github-pages-wang-zhan/"/>
      <url>/2019/09/30/jia-su-github-pages-wang-zhan/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="利用jsDelivr和Cloudflare免备案加速Github-Pages网站"><a href="#利用jsDelivr和Cloudflare免备案加速Github-Pages网站" class="headerlink" title="利用jsDelivr和Cloudflare免备案加速Github Pages网站"></a>利用jsDelivr和Cloudflare免备案加速Github Pages网站</h1><p>最近觉得学的东西不少，但是我从来没有记录过，最近正好因为新建了个博客，热乎劲还没过去，所以写点什么。</p><p>我比较穷，不想买个服务器，买了也浪费，同时又想写博客。还不想通过CSDN，简书之类的“广告网站”来写东西（最近发现在手机上用Chrome浏览器看简书的内容的时候会有弹屏广告，而且关不掉，遂放弃了简书）。突然想起了好久之前看过的Github Pages，于是照着网上的教程进行了梳理，最终创建了一个我还比较满意的博客。只是有一个很严重的缺陷，就是国内访问太慢了，查了很多教程，发现都是些接入国内CDN的教程，国内CDN不仅贵，而且你不备案是不能用的。对于我这样一个没啥需求的用户，还得做网站备案，太麻烦了。于是想能不能曲线救国，最终找到了一个比较有效，能提高Github Pages速度的方法，还不用花钱（可能要花点，但是不多）。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>先上效果（两个网页均是通过 <strong>清空缓存并硬性重新加载</strong> 方式来测试的）</p><p><img src="https://i.loli.net/2019/09/29/f9ij6oYm83UpadG.png" alt="这是我用的主题的作者给的示例站，直到35000ms的时候才算是正式加载完成"></p><p><img src="https://i.loli.net/2019/09/29/obNetxyrPZQ5fHR.png" alt="这是本站加载速度，8000ms的时候就基本上加载完成"></p><p>对于速度，大家可以自行测试，本站和 <a href="https://blinkfox.github.io" target="_blank" rel="noopener">blinkfox.github.io</a> 使用的是同一套模板，对方9.9s时还没跳到主页，我站8s就已经全部加载完成。那我做了什么改动呢？</p><h2 id="第一步——压缩图片"><a href="#第一步——压缩图片" class="headerlink" title="第一步——压缩图片"></a>第一步——压缩图片</h2><p>刚开始的时候没有头绪，因为不知道Github Pages能换域名。我一想，图片是显示的大头，先从压缩图片开始做起，刚好有一个公司 <a href="https://tinypng.com/" target="_blank" rel="noopener">TinyPNG</a> 提供了接口。首先我们需要打开它的官网，点击上面的 <em>Developer API</em>，输入你的名字和Email就可以获得每月500次的免费试用API的资格，你放心，这个量对于我们这种写小博客的人来说是非常够用的。申请完了之后要写个压缩的小程序。对于我来说，做个小程序还是轻而易举的，我在这里使用python来简单写写。根据官方文档说明，你首先需要下载它的库</p><blockquote><p>pip install –upgrade tinify</p></blockquote><p>然后就可以应用我这个遍历程序啦(突然发现被我删啦，重新写吧)</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> tinify<span class="token keyword">import</span> ostinify<span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token string">"YOUR_API_KEY"</span><span class="token keyword">def</span> <span class="token function">tinify_all_pic</span><span class="token punctuation">(</span>rootdir<span class="token punctuation">)</span><span class="token punctuation">:</span>    _files <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    list <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>rootdir<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rootdir<span class="token punctuation">,</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>            tinify_all_pic<span class="token punctuation">(</span>path<span class="token punctuation">)</span>        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isfile<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>            suffix <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> suffix <span class="token operator">==</span> <span class="token string">'.png'</span> <span class="token operator">or</span> suffix <span class="token operator">==</span> <span class="token string">'.jpg'</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>                source <span class="token operator">=</span> tinify<span class="token punctuation">.</span>from_file<span class="token punctuation">(</span>path<span class="token punctuation">)</span>                source<span class="token punctuation">.</span>to_file<span class="token punctuation">(</span>path<span class="token punctuation">)</span>tinify_all_pic<span class="token punctuation">(</span>r<span class="token string">"themes\hexo-theme-matery\source"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 这里是用我存放资源的一个文件夹做示范，根据你们的文件夹不同进行相应的更换</span></code></pre><p>压缩率通常在50%以上（特别是你用超过1M以上的图片的时候），这样你在加载的时候不就提高50%的加载速度了嘛😂（不是）。</p><p>这样操作之后你的加载速度可以提高至少20%以上（一些模板资源也被压缩了，有些图片没法用网页URL来代替）。</p><h2 id="第二步——使用jsDelivr对博客静态资源进行静态加速"><a href="#第二步——使用jsDelivr对博客静态资源进行静态加速" class="headerlink" title="第二步——使用jsDelivr对博客静态资源进行静态加速"></a>第二步——使用jsDelivr对博客静态资源进行静态加速</h2><p><img src="https://www.jsdelivr.com/img/logo-horizontal.svg" alt="jsDelivr"></p><p>jsDelivr是一个很著名的CDN加速商，这个服务商只对你GitHub里的静态资源进行加速，但是不和Cloudflare一样免费提供全站加速，不过Cf在国内没有节点，这个公司在中国是依托网宿科技（QUANTIL）进行CDN加速。</p><p><img src="https://i.loli.net/2019/09/30/65naHkyO2NFRWTe.png" alt="QUANTIL在国内的节点"></p><p>但是这也够了，也是提升我们速度的一个大杀器（Cloudflare只是起辅助作用）。首先你需要先传一个你网站编译完后的稳定版本放在你的GitHub里，这样就可以进行加速了。我们只需要通过这样来引用你的资源</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/user/repo@version/file</a></p></blockquote><p>举个例子，如果我们直接引用网站的资源是这样引用的。</p><blockquote><p><a href="https://github.com/gaowanliang/gaowanliang.github.io/blob/master/js/matery.js" target="_blank" rel="noopener">https://github.com/gaowanliang/gaowanliang.github.io/blob/master/js/matery.js</a></p></blockquote><p>其中 <code>gaowanliang</code> 是我的用户名，<code>gaowanliang.github.io</code> 是我的仓库名，那这样就可以进行套进去，效果就是这样:</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/gaowanliang/gaowanliang.github.io/js/matery.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/gaowanliang/gaowanliang.github.io/js/matery.js</a></p></blockquote><p>甚至如果你是js，css文件，可以进行min化，哪怕你的仓库里没有min的文件</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/gaowanliang/gaowanliang.github.io/js/matery.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/gaowanliang/gaowanliang.github.io/js/matery.min.js</a></p></blockquote><p>简单来说，如果你的文件放在master分支里，点开文件复制链接把链接里的 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> 换成 <a href="https://cdn.jsdelivr.net/gh/" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/</a> ，然后把 blob/master/ 删掉即可，然后就可以对你网站里的js，css，图片大换特换啦。你比如说这个模板的作者把用到的js，css都写在了 <code>_config.yml</code> 里，我们就可以进行全部替换</p><p><img src="https://i.loli.net/2019/09/30/Z2mdKjIeYJnSusi.png" alt="前提是你需要先传一个你网站编译完后的稳定版本放在你的GitHub里"></p><p>里面的图片也可以进行替换</p><p><img src="https://i.loli.net/2019/09/30/eEJ9BM3nFVcLfhI.png" alt="检测是不是本地，如果是本地就用本地图片，如果不是就使用jsdelivr加速"></p><p>这样你的加载速度还能再上一个台阶。</p><h2 id="第三步——使用Cloudflare进行全站加速"><a href="#第三步——使用Cloudflare进行全站加速" class="headerlink" title="第三步——使用Cloudflare进行全站加速"></a>第三步——使用Cloudflare进行全站加速</h2><p>因为Cf在国内没有节点，所以可能出现不加速反而减速的效果，但是有总比没有好，这里就简单说一说。</p><p>首先你需要注册一个域名，国内国外都有相关的域名的注册商这里就不详述了，因为手头没有空闲的域名了，这里就用<a href="https://starrycat.me/blog-add-cloudflare-cdn.html" target="_blank" rel="noopener">这篇博客</a>和<a href="https://blog.zfanw.com/github-pages-custom-domain/" target="_blank" rel="noopener">这篇博客</a>的内容进行介绍。</p><h3 id="注册-Cloudflare-账号"><a href="#注册-Cloudflare-账号" class="headerlink" title="注册 Cloudflare 账号"></a>注册 Cloudflare 账号</h3><p>要使用 Cloudflare 的服务，我们先要到官网注册账号：<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare 注册</a></p><p><img src="https://i.loli.net/2019/09/30/F4LKdBOuZAraGmb.png" alt></p><p>点击 Sign Up 注册，填写邮箱和密码即可。之后填上你要加速的博客主域名，然后点击 Add Site 添加。</p><p><img src="https://i.loli.net/2019/09/30/yPjJDU2BmAWkHKa.png" alt><br><img src="https://i.loli.net/2019/09/30/hMo7Psn1VLaQITU.png" alt></p><p>Cloudflare 在查询域名的 DNS 记录，点击 Next 继续，选择免费套餐</p><p><img src="https://i.loli.net/2019/09/30/y7eJdDb35YMkO94.png" alt></p><p><img src="https://i.loli.net/2019/09/30/N4iItqoAxKXQZsY.png" alt></p><p>这里我们是免费套餐，可以无视直接点击 Confirm 确认。</p><p><img src="https://i.loli.net/2019/09/30/CmZ9h3xfajpMesw.png" alt></p><h3 id="修改-DNS-域名服务器"><a href="#修改-DNS-域名服务器" class="headerlink" title="修改 DNS 域名服务器"></a>修改 DNS 域名服务器</h3><p>这里是域名的 DNS 记录查询结果，如有遗落，可自行添加。建议所有全部访问都通过 CDN 加速，其余默认，确认后继续。</p><p><img src="https://i.loli.net/2019/09/30/kiNjrDAHJTfV6Rm.png" alt></p><p>然后去你的域名提供商修改默认域名服务器为 Cloudflare 提供的，修改后继续，更改成功需要几分钟或更长的时间。时不时 Check 一下。</p><p><img src="https://i.loli.net/2019/09/30/9Amja7kMRKbTNp2.png" alt></p><h3 id="更换到你的自定义域名"><a href="#更换到你的自定义域名" class="headerlink" title="更换到你的自定义域名"></a>更换到你的自定义域名</h3><p>首先我们需要在仓库的设置里填入自定义域名，如下图：</p><p><img src="https://i.loli.net/2019/09/30/WTPCJ4iv6Eq8gSw.png" alt></p><p>此时访问 example.zfanw.com，浏览器会提示：</p><blockquote><p>example.zfanw.com’s server IP address could not be found.</p></blockquote><p>IP 地址未找到 - 因为我们还没做任何 DNS 解析的工作。</p><h3 id="绑定-CNAME"><a href="#绑定-CNAME" class="headerlink" title="绑定 CNAME"></a>绑定 CNAME</h3><p>一般情况下，我们是添加 A 记录将域名指向 IP。但 Github Pages 是通过 CNAME 绑定的 - CNAME 指 Canonical Name record，其实就是域名的别名。</p><p>在 DNS 管理中添加一条 CNAME 记录，将 example 子域名指向 chenxsan.github.io</p><p>然后就成功了</p><h2 id="享受一下吧"><a href="#享受一下吧" class="headerlink" title="享受一下吧"></a>享受一下吧</h2><p>经过加速后你的网站就可以达到我说的速度啦，虽然没有很快，但是在免备案的情况下达到这个速度已经很好了（总比10s才相应网页好吧）。当然我还在想办法继续优化，有新方法还会更新的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script></body></html>]]></content>
      
      
      <categories>
          
          <category> 加速 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Pages </tag>
            
            <tag> 加速 </tag>
            
            <tag> jsdelivr </tag>
            
            <tag> Cloudflare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OMNET++入门教程|第1章 —— TicToc模型</title>
      <link href="/2019/09/26/omnet-ru-men-jiao-cheng-2/"/>
      <url>/2019/09/26/omnet-ru-men-jiao-cheng-2/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><a href="https://docs.omnetpp.org/tutorials/tictoc/part1/" target="_blank" rel="noopener">官方教程链接</a></p><h1 id="OMNET-入门教程-第1章-——-TicToc模型"><a href="#OMNET-入门教程-第1章-——-TicToc模型" class="headerlink" title="OMNET++入门教程|第1章 —— TicToc模型"></a>OMNET++入门教程|第1章 —— TicToc模型</h1><h2 id="1-模型"><a href="#1-模型" class="headerlink" title="1 模型"></a>1 模型</h2><p>首先，让我们从一个由两个节点组成的“网络”开始。节点将做一些简单的事情：其中一个节点将创建一个数据包，两个节点将继续来回传递相同的数据包。我将调用节点tic和toc。稍后我们将逐步改进这个模型，在每个步骤中来引入OMNET++特性。</p><p>以下是从零开始实现第一个模拟的步骤。</p><h2 id="2-建立项目"><a href="#2-建立项目" class="headerlink" title="2 建立项目"></a>2 建立项目</h2><p>首先打开OMNET++的主界面，在主菜单中选择 <em>File-> New -> OMNeT++ Project</em> </p><p><img src="https://i.loli.net/2019/09/27/xKrMTzNh4eAZtWb.jpg" alt><br>然后会出现这个界面<br><img src="https://i.loli.net/2019/09/27/3tzclP761W2xTNv.jpg" alt><br>Project name输入TT（官方直接有一个tictoc，如果输入tictoc就直接进入它的例子了，这里我们尝试从头开始写），其他的保持默认即可，点击Next（<strong>别点错成Finish</strong>），在让你选择 <em>initial content</em>时，选择 <em>Empty project</em>，然后一路Next，最后无法选择Next时选择Finish。最后的效果如图<br><img src="https://i.loli.net/2019/09/27/NUyIA9vVSc5jhfg.jpg" alt></p><h2 id="3-添加NED文件"><a href="#3-添加NED文件" class="headerlink" title="3 添加NED文件"></a>3 添加NED文件</h2><p>OMNeT ++使用NED文件来定义组件并将它们组装成更大的单元，例如网络。我们开始通过添加NED文件来实现我们的模型。要将文件添加到项目中，请在左侧的项目资源管理器面板中右键单击项目目录 ，然后从菜单中选择 <em>File-> New -> Network Description File (NED)</em>。下面的 <em>File name</em>输入tt.ned，然后点击Finish即可</p><p><img src="https://i.loli.net/2019/09/27/8GVsEzim71RcJto.png" alt></p><p><img src="https://i.loli.net/2019/09/27/8s9RTVca4UGNfXz.png" alt></p><p>然后就可以开始构建网络了，切换到 <em>Source</em> 模式，然后输入以下内容：</p><pre class=" language-cpp"><code class="language-cpp">simple Txc1<span class="token punctuation">{</span>    gates<span class="token operator">:</span>        input in<span class="token punctuation">;</span>        output out<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Two instances (tic and toc) of Txc1 connected both ways.</span><span class="token comment" spellcheck="true">// Tic and toc will pass messages to one another.</span><span class="token comment" spellcheck="true">//</span>network Tictoc1<span class="token punctuation">{</span>    submodules<span class="token operator">:</span>        tic<span class="token operator">:</span> Txc1<span class="token punctuation">;</span>        toc<span class="token operator">:</span> Txc1<span class="token punctuation">;</span>    connections<span class="token operator">:</span>        tic<span class="token punctuation">.</span>out <span class="token operator">--</span><span class="token operator">></span> <span class="token punctuation">{</span>  delay <span class="token operator">=</span> 100ms<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">--</span><span class="token operator">></span> toc<span class="token punctuation">.</span>in<span class="token punctuation">;</span>        tic<span class="token punctuation">.</span>in <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">{</span>  delay <span class="token operator">=</span> 100ms<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">&lt;</span><span class="token operator">--</span> toc<span class="token punctuation">.</span>out<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://i.loli.net/2019/09/27/1PZGJVpD4ug5jcd.png" alt></p><p>然后切换回 <em>Design</em> 模式，就会看到类似如下的场景</p><p><img src="https://i.loli.net/2019/09/27/Pf2wZY35xtbuicC.png" alt></p><p>那我们来看一下两块代码是什么意思</p><p>首先，第一块定义了一个简单模块Txc1</p><p>第二块定义了一个复合模块(类型) Tictoc1,其中包含子模块tic和toc,它们都是简单模块类型Txc1的实例。Tic的输出门(out)连接到toc的输入门(in),Toc的输出门(out)连接到tic的输入门(in) ,传输延迟均为100ms。</p><h2 id="4-添加C-文件"><a href="#4-添加C-文件" class="headerlink" title="4 添加C++文件"></a>4 添加C++文件</h2><p>现在，我们需要在C++中实现Txc1简单模块的功能。从项目的菜单中选择 <em>File -> Other</em>,然后在下面的选择栏里选择 <em>C/C++ -> Source File</em> ，创建一个名为txc1.cc的文件，并输入以下内容：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;omnetpp.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> omnetpp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Derive the Txc1 class from cSimpleModule. In the Tictoc1 network, * both the `tic' and `toc' modules are Txc1 objects, created by OMNeT++ * at the beginning of the simulation. */</span><span class="token keyword">class</span> <span class="token class-name">Txc1</span> <span class="token operator">:</span> <span class="token keyword">public</span> cSimpleModule<span class="token punctuation">{</span>  <span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// The following redefined virtual function holds the algorithm.</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>cMessage <span class="token operator">*</span>msg<span class="token punctuation">)</span> override<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// The module class needs to be registered with OMNeT++</span><span class="token function">Define_Module</span><span class="token punctuation">(</span>Txc1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> Txc1<span class="token operator">::</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Initialize is called at the beginning of the simulation.</span>    <span class="token comment" spellcheck="true">// To bootstrap the tic-toc-tic-toc process, one of the modules needs</span>    <span class="token comment" spellcheck="true">// to send the first message. Let this be `tic'.</span>    <span class="token comment" spellcheck="true">// Am I Tic or Toc?</span>    <span class="token comment" spellcheck="true">//仿真初始化，由节点tic发出第一条消息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"tic"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// create and send first message on gate "out". "tictocMsg" is an</span>        <span class="token comment" spellcheck="true">// arbitrary string which will be the name of the message object.</span>        <span class="token comment" spellcheck="true">//创建输出门“out”发出第一条消息"tictocMsg"，不过发的啥这里并不关心</span>        cMessage <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">cMessage</span><span class="token punctuation">(</span><span class="token string">"tictocMsg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> Txc1<span class="token operator">::</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>cMessage <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// The handleMessage() method is called whenever a message arrives</span>    <span class="token comment" spellcheck="true">// at the module. Here, we just send it to the other module, through</span>    <span class="token comment" spellcheck="true">// gate `out'. Because both `tic' and `toc' does the same, the message</span>    <span class="token comment" spellcheck="true">// will bounce between the two.</span>    <span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// send out the message</span><span class="token punctuation">}</span></code></pre><p><img src="https://i.loli.net/2019/09/27/bOmDvLfCaF3KBlI.png" alt><br><img src="https://i.loli.net/2019/09/27/ItZmzQnHFPgYpE6.png" alt><br><img src="https://i.loli.net/2019/09/27/5gGz376LDIKbBaX.png" alt></p><p>根据 NED 文件中定义的字模块关系，<em>initialize()</em> 函数中节点 tic 从输出门“out”发出的消息经过 100ms 传输延迟必然到达节点 toc的输入门“tic”，并触发其 <em>handleMessage()</em> 函数。 不难看出该消息就像一只乒乓球，将在两个节点间来回传输。不过请注意，此模拟中没有内置停止条件：它将永远持续。你可以在IDE上让它停止运行。</p><h2 id="5-配置omn​​etpp-ini"><a href="#5-配置omn​​etpp-ini" class="headerlink" title="5 配置omn​​etpp.ini"></a>5 配置omn​​etpp.ini</h2><p>为了能够运行模拟，我们需要创建<code>omnetpp.ini</code>文件。<code>omnetpp.ini</code>告诉仿真程序要模拟哪个网络（因为ned文件可能包含多个网络），可以将参数传递给模型，显式指定随机数生成器的种子等。</p><p>从菜单里选择 <em>File -> New -> Initialization file (INI)</em> 创建<code>omnetpp.ini</code>文件。新文件将在IniFile编辑器中打开。作为ned编辑器，inifile编辑器还有两种模式，<em>Form</em>和<em>Source</em>，用于编辑相同的内容。前者更适合配置仿真内核，后者更适合输入模块参数。</p><p>现在，只需切换到 <em>Source</em> 模式并输入以下内容：</p><pre><code>[General]network = Tictoc1</code></pre><p><img src="https://i.loli.net/2019/09/27/ZHyoesIrKWSPMjt.png" alt><br><img src="https://i.loli.net/2019/09/27/hHW5ISEtoTdCa3v.png" alt></p><p>点击 <em>Run</em> 或使用快捷键 <code>Ctrl+F11</code> 运行，可能弹出两个提示框，不用管他，直接运行即可，最后会弹出一个窗口来显示仿真结果，效果如图。</p><p><img src="https://i.loli.net/2019/09/27/b8Bhryno1U5luvL.gif" alt></p><p>下一节我会着重讲一下模拟的过程。就说到这里吧，有什么问题大家可以通过评论区联系我。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script></body></html>]]></content>
      
      
      <categories>
          
          <category> OMNET++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OMNET++ </tag>
            
            <tag> TicToc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OMNET++入门教程|第0章——安装</title>
      <link href="/2019/09/24/omnet-ru-men-jiao-cheng/"/>
      <url>/2019/09/24/omnet-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="OMNET-入门教程-第0章——安装"><a href="#OMNET-入门教程-第0章——安装" class="headerlink" title="OMNET++入门教程|第0章——安装"></a>OMNET++入门教程|第0章——安装</h1><p>最近需要学的东西不少，于是准备写点什么。正好最近在研究通信协议方面的知识，老师建议学一学OMNET++，正好网上的相关资料比较少，我自己也写点什么。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>首先第一步去官网下载，打开 <a href="https://omnetpp.org/" target="_blank" rel="noopener">OMNET++的官网</a>，选择右上角的Download，选择合适的版本来进行下载，比如我就是Windows 10 64位，就需要下载Windows版本<br><img src="https://i.loli.net/2019/09/26/4MKnyYdFTQtv2zO.jpg" alt="根据自己的版本进行安装"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完成后是一个压缩包，在合适的目录解压后，第一次遇到下载软件的压缩包里面没有安装包，感觉还是束手无策的，赶紧上网查了查，终于知道了具体怎么安装，首先先给一张图片<br><img src="https://pic4.zhimg.com/81877348c76aada1e5db9e97cfb3733b_r.jpg" alt="安装过程"><br>这个图片写的已经很清楚了，首先双击运行<code>mingwenv.cmd</code>，然后文件会自动解压，按照其他网站的理论，可能你需要先安装G++之类的编译器，但是我没有遇到这个情况，如果有人遇到什么情况也可以在评论区留言给我。</p><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>第二步就是输入<code>./configure</code>这个命令，它会自动执行，最后出现 <strong>Good！</strong> 之类的话，说明这一步成功了。然后接着输入<code>make</code>命令来进行编译，时间非常长，耐心等待，等屏幕上输出 <strong>Now you can type “omnetpp” to start the IDE</strong> 字样，说明安装完成了，可以直接输入<code>omnetpp</code>打开IDE。然后因为我比较懒，相信它应该有实体的exe，然后就找了起来。这个时候我其实下意识的进入<code>./bin</code>这个文件夹，因为这个文件夹通常是用来存放二进制文件的，但是发现里面没有IDE，是因为其实这个软件没有IDE应该也能运行（我想不出一个仿真软件在没有IDE的情况下是怎么仿真的），真正的IDE是在<code>./ide</code>这个文件夹当中的，这个时候可以建立一个快捷方式放在根目录，更方便。就不用每次通过进命令行输入<code>omnetpp</code>进入IDE了。</p><p><img src="https://i.loli.net/2019/09/26/95I1kyYfN7pJTCO.jpg" alt="omnet++主界面"></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>具体安装过程虽然不如安装包点点简单，但是还是蛮简单的，但是我没有在官方文档找到相关教程，可能还是有点欠缺吧。就说到这里吧，有什么问题大家可以通过评论区联系我，或者直接通过右面的Daovoice联系我（最好是评论区，那个我可能不看），下次我将介绍一个简单的例子来入门OMNET++。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script></body></html>]]></content>
      
      
      <categories>
          
          <category> OMNET++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OMNET++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
