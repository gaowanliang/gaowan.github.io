<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划（DP）相关问题简单思想</title>
      <link href="/2019/09/24/hello-world/"/>
      <url>/2019/09/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>动态规划( Dynamic Programming, DP )是一种用来解决一类最优化问题的算法思想。<br>简单来说，<strong>动态规划将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得<br>到原问题的最优解</strong>。需要注意的是，动态规划会将每个求解过的子问题的解记录下来，这样<br>当下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算。</p><h3 id="一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决。"><a href="#一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决。" class="headerlink" title="一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决。"></a>一个问题必须拥有<code>重叠子问题</code>和<code>最优子结构</code>，才能使用动态规划去解决。</h3><h4 id="什么是重叠子问题？"><a href="#什么是重叠子问题？" class="headerlink" title="什么是重叠子问题？"></a>什么是重叠子问题？</h4><p>比如经典的斐波那契数列，我们都知道，斐波那契数列是递归算法的一个经典练习，通常初学递归算法的时候，斐波那契数列一般是这样写：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这种写法虽然简单，但是其实做了很多无用计算，比如我们算n==5时，我们可以得到<code>F(5) = F(4) + F(3)</code>，接下来在计算F(4)时又会有<code>F(4) = F(3) + F(2)</code>。这时候如果不采取措施，<code>F(3)</code>将会被计算两次。可以推知，如果n很大，重复计算的次数将难以想象。事实上，由于没有及时保存中间计算的结果，实际复杂度会高达 O(2^n^)  , 即每次都会计算<code>F( n - 1 )</code> 和 <code>F( n - 2 )</code>这两个分支，基本不能承受n较大的情况。<br>为了避免重复计算，可以开一个一维数组<code>dp</code> ,用以保存已经计算过的结果，其中<code>dp[n]</code>记录<code>F(n)</code>的结果，并用<code>dp[n] = -1</code> 表示<code>F(n)</code>当前还没有被计算过。 </p><pre class=" language-javascript"><code class="language-javascript">int dp<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>然后就可以在递归当中判断<code>dp[n]</code>是否是-1 :如果不是-1 ，说明已经计算过<code>F(n)</code>,直接返回<code>dp[n]</code><br>就是结果；否则，按照递归式进行递归。代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//递归边界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp <span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//已经计算过，直接返回结果，不再重复计算</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">F</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">F</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计算 F(n) ,并保存至 dp[n]</span>            <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 F(n)的结果</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样就把已经计算过的内容记录了下来，于是当下次再碰到需要计算相同的内容时，就<br>能直接使用上次计算的结果，这可以省去大半无效计算，而这也是记忆化搜索这个名字的由<br>来。通过记忆化搜索，把复杂度从O( 2^n^ )降到了 O( n )。<br>像这样，在计算过程中有大量重复计算的问题，而这些问题可以用记忆化搜索来减少运算的问题，都可以说它有<strong>重复子问题</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
