<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OMNET++入门教程|第1章 —— TicToc模型</title>
      <link href="/2019/09/26/omnet-ru-men-jiao-cheng-2/"/>
      <url>/2019/09/26/omnet-ru-men-jiao-cheng-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.omnetpp.org/tutorials/tictoc/part1/" target="_blank" rel="noopener">官方教程链接</a></p><h2 id="1-1模型"><a href="#1-1模型" class="headerlink" title="1.1模型"></a>1.1模型</h2><p>首先，让我们从一个由两个节点组成的“网络”开始。节点将做一些简单的事情：其中一个节点将创建一个数据包，两个节点将继续来回传递相同的数据包。我将调用节点tic和toc。稍后我们将逐步改进这个模型，在每个步骤中来引入OMNET++特性。</p><p>以下是从零开始实现第一个模拟的步骤。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OMNET++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OMNET++ </tag>
            
            <tag> TicToc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OMNET++入门教程|第0章——安装</title>
      <link href="/2019/09/24/omnet-ru-men-jiao-cheng/"/>
      <url>/2019/09/24/omnet-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="OMNET-入门教程-第0章——安装"><a href="#OMNET-入门教程-第0章——安装" class="headerlink" title="OMNET++入门教程|第0章——安装"></a>OMNET++入门教程|第0章——安装</h1><p>最近需要学的东西不少，于是准备写点什么。正好最近在研究通信协议方面的知识，老师建议学一学OMNET++，正好网上的相关资料比较少，我自己也写点什么。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>首先第一步去官网下载，打开 <a href="https://omnetpp.org/" target="_blank" rel="noopener">OMNET++的官网</a>，选择右上角的Download，选择合适的版本来进行下载，比如我就是Windows 10 64位，就需要下载Windows版本<br><img src="https://i.loli.net/2019/09/26/4MKnyYdFTQtv2zO.jpg" alt="根据自己的版本进行安装"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完成后是一个压缩包，在合适的目录解压后，第一次遇到下载软件的压缩包里面没有安装包，感觉还是束手无策的，赶紧上网查了查，终于知道了具体怎么安装，首先先给一张图片<br><img src="https://pic4.zhimg.com/81877348c76aada1e5db9e97cfb3733b_r.jpg" alt="安装过程"><br>这个图片写的已经很清楚了，首先双击运行<code>mingwenv.cmd</code>，然后文件会自动解压，按照其他网站的理论，可能你需要先安装G++之类的编译器，但是我没有遇到这个情况，如果有人遇到什么情况也可以在评论区留言给我。</p><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>第二步就是输入<code>./configure</code>这个命令，它会自动执行，最后出现 <strong>Good！</strong> 之类的话，说明这一步成功了。然后接着输入<code>make</code>命令来进行编译，时间非常长，耐心等待，等屏幕上输出 <strong>Now you can type “omnetpp” to start the IDE</strong> 字样，说明安装完成了，可以直接输入<code>omnetpp</code>打开IDE。然后因为我比较懒，相信它应该有实体的exe，然后就找了起来。这个时候我其实下意识的进入<code>./bin</code>这个文件夹，因为这个文件夹通常是用来存放二进制文件的，但是发现里面没有IDE，是因为其实这个软件没有IDE应该也能运行（我想不出一个仿真软件在没有IDE的情况下是怎么仿真的），真正的IDE是在<code>./ide</code>这个文件夹当中的，这个时候可以建立一个快捷方式放在根目录，更方便。就不用每次通过进命令行输入<code>omnetpp</code>进入IDE了。</p><p><img src="https://i.loli.net/2019/09/26/95I1kyYfN7pJTCO.jpg" alt="omnet++主界面"></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>具体安装过程虽然不如安装包点点简单，但是还是蛮简单的，但是我没有在官方文档找到相关教程，可能还是有点欠缺吧。就说到这里吧，有什么问题大家可以通过评论区联系我，或者直接通过右面的Daovoice联系我（最好是评论区，那个我可能不看），下次我将介绍一个简单的例子来入门OMNET++。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OMNET++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OMNET++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划（DP）相关问题简单思想</title>
      <link href="/2019/09/24/hello-world/"/>
      <url>/2019/09/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>动态规划 ( Dynamic Programming, DP)是一种用来解决一类最优化问题的算法思想。 简单来说，<strong>动态规划将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得 到原问题的最优解</strong>。需要注意的是，动态规划会将每个求解过的子问题的解记录下来，这样当下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算。</p><h3 id="一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决。"><a href="#一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决。" class="headerlink" title="一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决。"></a>一个问题必须拥有<code>重叠子问题</code>和<code>最优子结构</code>，才能使用动态规划去解决。</h3><h4 id="什么是重叠子问题？"><a href="#什么是重叠子问题？" class="headerlink" title="什么是重叠子问题？"></a>什么是重叠子问题？</h4><p>比如经典的斐波那契数列，我们都知道，斐波那契数列是递归算法的一个经典练习，通常初学递归算法的时候，斐波那契数列一般是这样写：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这种写法虽然简单，但是其实做了很多无用计算，比如我们算n==5时，我们可以得到<code>F(5) = F(4) + F(3)</code>，接下来在计算F(4)时又会有<code>F(4) = F(3) + F(2)</code>。这时候如果不采取措施，<code>F(3)</code>将会被计算两次。可以推知，如果n很大，重复计算的次数将难以想象。事实上，由于没有及时保存中间计算的结果，实际复杂度会高达 O(2^n^)  , 即每次都会计算<code>F( n - 1 )</code> 和 <code>F( n - 2 )</code>这两个分支，基本不能承受n较大的情况。<br>为了避免重复计算，可以开一个一维数组<code>dp</code> ,用以保存已经计算过的结果，其中<code>dp[n]</code>记录<code>F(n)</code>的结果，并用<code>dp[n] = -1</code> 表示<code>F(n)</code>当前还没有被计算过。 </p><pre class=" language-javascript"><code class="language-javascript">int dp<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>然后就可以在递归当中判断<code>dp[n]</code>是否是-1 :如果不是-1 ，说明已经计算过<code>F(n)</code>,直接返回<code>dp[n]</code><br>就是结果；否则，按照递归式进行递归。代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//递归边界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp <span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//已经计算过，直接返回结果，不再重复计算</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">F</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">F</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计算 F(n) ,并保存至 dp[n]</span>            <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 F(n)的结果</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样就把已经计算过的内容记录了下来，于是当下次再碰到需要计算相同的内容时，就<br>能直接使用上次计算的结果，这可以省去大半无效计算，而这也是记忆化搜索这个名字的由<br>来。通过记忆化搜索，把复杂度从O( 2^n^ )降到了 O( n )。<br>像这样，在计算过程中有大量重复计算的问题，而这些问题可以用记忆化搜索来减少运算的问题，都可以说它有<strong>重复子问题</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
