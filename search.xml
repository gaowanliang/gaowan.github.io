<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OMNET++入门教程|第1章 —— TicToc模型</title>
      <link href="/2019/09/26/omnet-ru-men-jiao-cheng-2/"/>
      <url>/2019/09/26/omnet-ru-men-jiao-cheng-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.omnetpp.org/tutorials/tictoc/part1/" target="_blank" rel="noopener">官方教程链接</a></p><h1 id="OMNET-入门教程-第1章-——-TicToc模型"><a href="#OMNET-入门教程-第1章-——-TicToc模型" class="headerlink" title="OMNET++入门教程|第1章 —— TicToc模型"></a>OMNET++入门教程|第1章 —— TicToc模型</h1><h2 id="1-模型"><a href="#1-模型" class="headerlink" title="1 模型"></a>1 模型</h2><p>首先，让我们从一个由两个节点组成的“网络”开始。节点将做一些简单的事情：其中一个节点将创建一个数据包，两个节点将继续来回传递相同的数据包。我将调用节点tic和toc。稍后我们将逐步改进这个模型，在每个步骤中来引入OMNET++特性。</p><p>以下是从零开始实现第一个模拟的步骤。</p><h2 id="2-建立项目"><a href="#2-建立项目" class="headerlink" title="2 建立项目"></a>2 建立项目</h2><p>首先打开OMNET++的主界面，在主菜单中选择 <em>File-&gt; New -&gt; OMNeT++ Project</em> </p><p><img src="https://i.loli.net/2019/09/27/xKrMTzNh4eAZtWb.jpg" alt=""><br>然后会出现这个界面<br><img src="https://i.loli.net/2019/09/27/3tzclP761W2xTNv.jpg" alt=""><br>Project name输入TT（官方直接有一个tictoc，如果输入tictoc就直接进入它的例子了，这里我们尝试从头开始写），其他的保持默认即可，点击Next（<strong>别点错成Finish</strong>），在让你选择 <em>initial content</em>时，选择 <em>Empty project</em>，然后一路Next，最后无法选择Next时选择Finish。最后的效果如图<br><img src="https://i.loli.net/2019/09/27/NUyIA9vVSc5jhfg.jpg" alt=""></p><h2 id="3-添加NED文件"><a href="#3-添加NED文件" class="headerlink" title="3 添加NED文件"></a>3 添加NED文件</h2><p>OMNeT ++使用NED文件来定义组件并将它们组装成更大的单元，例如网络。我们开始通过添加NED文件来实现我们的模型。要将文件添加到项目中，请在左侧的项目资源管理器面板中右键单击项目目录 ，然后从菜单中选择 <em>File-&gt; New -&gt; Network Description File (NED)</em>。下面的 <em>File name</em>输入tt.ned，然后点击Finish即可</p><p><img src="https://i.loli.net/2019/09/27/8GVsEzim71RcJto.png" alt=""></p><p><img src="https://i.loli.net/2019/09/27/8s9RTVca4UGNfXz.png" alt=""></p><p>然后就可以开始构建网络了，切换到 <em>Source</em> 模式，然后输入以下内容：</p><pre class=" language-cpp"><code class="language-cpp">simple Txc1<span class="token punctuation">{</span>    gates<span class="token operator">:</span>        input in<span class="token punctuation">;</span>        output out<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Two instances (tic and toc) of Txc1 connected both ways.</span><span class="token comment" spellcheck="true">// Tic and toc will pass messages to one another.</span><span class="token comment" spellcheck="true">//</span>network Tictoc1<span class="token punctuation">{</span>    submodules<span class="token operator">:</span>        tic<span class="token operator">:</span> Txc1<span class="token punctuation">;</span>        toc<span class="token operator">:</span> Txc1<span class="token punctuation">;</span>    connections<span class="token operator">:</span>        tic<span class="token punctuation">.</span>out <span class="token operator">--</span><span class="token operator">></span> <span class="token punctuation">{</span>  delay <span class="token operator">=</span> 100ms<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">--</span><span class="token operator">></span> toc<span class="token punctuation">.</span>in<span class="token punctuation">;</span>        tic<span class="token punctuation">.</span>in <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">{</span>  delay <span class="token operator">=</span> 100ms<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">&lt;</span><span class="token operator">--</span> toc<span class="token punctuation">.</span>out<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://i.loli.net/2019/09/27/1PZGJVpD4ug5jcd.png" alt=""></p><p>然后切换回 <em>Design</em> 模式，就会看到类似如下的场景</p><p><img src="https://i.loli.net/2019/09/27/Pf2wZY35xtbuicC.png" alt=""></p><p>那我们来看一下两块代码是什么意思</p><p>首先，第一块定义了一个简单模块Txc1</p><p>第二块定义了一个复合模块(类型) Tictoc1,其中包含子模块tic和toc,它们都是简单模块类型Txc1的实例。Tic的输出门(out)连接到toc的输入门(in),Toc的输出门(out)连接到tic的输入门(in) ,传输延迟均为100ms。</p><h2 id="4-添加C-文件"><a href="#4-添加C-文件" class="headerlink" title="4 添加C++文件"></a>4 添加C++文件</h2><p>现在，我们需要在C++中实现Txc1简单模块的功能。从项目的菜单中选择 <em>File -&gt; Other</em>,然后在下面的选择栏里选择 <em>C/C++ -&gt; Source File</em> ，创建一个名为txc1.cc的文件，并输入以下内容：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;omnetpp.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> omnetpp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Derive the Txc1 class from cSimpleModule. In the Tictoc1 network, * both the `tic' and `toc' modules are Txc1 objects, created by OMNeT++ * at the beginning of the simulation. */</span><span class="token keyword">class</span> <span class="token class-name">Txc1</span> <span class="token operator">:</span> <span class="token keyword">public</span> cSimpleModule<span class="token punctuation">{</span>  <span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// The following redefined virtual function holds the algorithm.</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>cMessage <span class="token operator">*</span>msg<span class="token punctuation">)</span> override<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// The module class needs to be registered with OMNeT++</span><span class="token function">Define_Module</span><span class="token punctuation">(</span>Txc1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> Txc1<span class="token operator">::</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Initialize is called at the beginning of the simulation.</span>    <span class="token comment" spellcheck="true">// To bootstrap the tic-toc-tic-toc process, one of the modules needs</span>    <span class="token comment" spellcheck="true">// to send the first message. Let this be `tic'.</span>    <span class="token comment" spellcheck="true">// Am I Tic or Toc?</span>    <span class="token comment" spellcheck="true">//仿真初始化，由节点tic发出第一条消息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"tic"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// create and send first message on gate "out". "tictocMsg" is an</span>        <span class="token comment" spellcheck="true">// arbitrary string which will be the name of the message object.</span>        <span class="token comment" spellcheck="true">//创建输出门“out”发出第一条消息"tictocMsg"，不过发的啥这里并不关心</span>        cMessage <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">cMessage</span><span class="token punctuation">(</span><span class="token string">"tictocMsg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> Txc1<span class="token operator">::</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>cMessage <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// The handleMessage() method is called whenever a message arrives</span>    <span class="token comment" spellcheck="true">// at the module. Here, we just send it to the other module, through</span>    <span class="token comment" spellcheck="true">// gate `out'. Because both `tic' and `toc' does the same, the message</span>    <span class="token comment" spellcheck="true">// will bounce between the two.</span>    <span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// send out the message</span><span class="token punctuation">}</span></code></pre><p><img src="https://i.loli.net/2019/09/27/bOmDvLfCaF3KBlI.png" alt=""><br><img src="https://i.loli.net/2019/09/27/ItZmzQnHFPgYpE6.png" alt=""><br><img src="https://i.loli.net/2019/09/27/5gGz376LDIKbBaX.png" alt=""></p><p>根据 NED 文件中定义的字模块关系，<em>initialize()</em> 函数中节点 tic 从输出门“out”发出的消息经过 100ms 传输延迟必然到达节点 toc的输入门“tic”，并触发其 <em>handleMessage()</em> 函数。 不难看出该消息就像一只乒乓球，将在两个节点间来回传输。不过请注意，此模拟中没有内置停止条件：它将永远持续。你可以在IDE上让它停止运行。</p><h2 id="5-配置omn​​etpp-ini"><a href="#5-配置omn​​etpp-ini" class="headerlink" title="5 配置omn​​etpp.ini"></a>5 配置omn​​etpp.ini</h2><p>为了能够运行模拟，我们需要创建<code>omnetpp.ini</code>文件。<code>omnetpp.ini</code>告诉仿真程序要模拟哪个网络（因为ned文件可能包含多个网络），可以将参数传递给模型，显式指定随机数生成器的种子等。</p><p>从菜单里选择 <em>File -&gt; New -&gt; Initialization file (INI)</em> 创建<code>omnetpp.ini</code>文件。新文件将在IniFile编辑器中打开。作为ned编辑器，inifile编辑器还有两种模式，<em>Form</em>和<em>Source</em>，用于编辑相同的内容。前者更适合配置仿真内核，后者更适合输入模块参数。</p><p>现在，只需切换到 <em>Source</em> 模式并输入以下内容：</p><pre><code>[General]network = Tictoc1</code></pre><p><img src="https://i.loli.net/2019/09/27/ZHyoesIrKWSPMjt.png" alt=""><br><img src="https://i.loli.net/2019/09/27/hHW5ISEtoTdCa3v.png" alt=""></p><p>点击 <em>Run</em> 或使用快捷键 <code>Ctrl+F11</code> 运行，可能弹出两个提示框，不用管他，直接运行即可，最后会弹出一个窗口来显示仿真结果，效果如图。</p><p><img src="https://i.loli.net/2019/09/27/b8Bhryno1U5luvL.gif" alt=""></p><p>下一节我会着重讲一下模拟的过程。就说到这里吧，有什么问题大家可以通过评论区联系我。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OMNET++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OMNET++ </tag>
            
            <tag> TicToc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OMNET++入门教程|第0章——安装</title>
      <link href="/2019/09/24/omnet-ru-men-jiao-cheng/"/>
      <url>/2019/09/24/omnet-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="OMNET-入门教程-第0章——安装"><a href="#OMNET-入门教程-第0章——安装" class="headerlink" title="OMNET++入门教程|第0章——安装"></a>OMNET++入门教程|第0章——安装</h1><p>最近需要学的东西不少，于是准备写点什么。正好最近在研究通信协议方面的知识，老师建议学一学OMNET++，正好网上的相关资料比较少，我自己也写点什么。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>首先第一步去官网下载，打开 <a href="https://omnetpp.org/" target="_blank" rel="noopener">OMNET++的官网</a>，选择右上角的Download，选择合适的版本来进行下载，比如我就是Windows 10 64位，就需要下载Windows版本<br><img src="https://i.loli.net/2019/09/26/4MKnyYdFTQtv2zO.jpg" alt="根据自己的版本进行安装"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完成后是一个压缩包，在合适的目录解压后，第一次遇到下载软件的压缩包里面没有安装包，感觉还是束手无策的，赶紧上网查了查，终于知道了具体怎么安装，首先先给一张图片<br><img src="https://pic4.zhimg.com/81877348c76aada1e5db9e97cfb3733b_r.jpg" alt="安装过程"><br>这个图片写的已经很清楚了，首先双击运行<code>mingwenv.cmd</code>，然后文件会自动解压，按照其他网站的理论，可能你需要先安装G++之类的编译器，但是我没有遇到这个情况，如果有人遇到什么情况也可以在评论区留言给我。</p><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>第二步就是输入<code>./configure</code>这个命令，它会自动执行，最后出现 <strong>Good！</strong> 之类的话，说明这一步成功了。然后接着输入<code>make</code>命令来进行编译，时间非常长，耐心等待，等屏幕上输出 <strong>Now you can type “omnetpp” to start the IDE</strong> 字样，说明安装完成了，可以直接输入<code>omnetpp</code>打开IDE。然后因为我比较懒，相信它应该有实体的exe，然后就找了起来。这个时候我其实下意识的进入<code>./bin</code>这个文件夹，因为这个文件夹通常是用来存放二进制文件的，但是发现里面没有IDE，是因为其实这个软件没有IDE应该也能运行（我想不出一个仿真软件在没有IDE的情况下是怎么仿真的），真正的IDE是在<code>./ide</code>这个文件夹当中的，这个时候可以建立一个快捷方式放在根目录，更方便。就不用每次通过进命令行输入<code>omnetpp</code>进入IDE了。</p><p><img src="https://i.loli.net/2019/09/26/95I1kyYfN7pJTCO.jpg" alt="omnet++主界面"></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>具体安装过程虽然不如安装包点点简单，但是还是蛮简单的，但是我没有在官方文档找到相关教程，可能还是有点欠缺吧。就说到这里吧，有什么问题大家可以通过评论区联系我，或者直接通过右面的Daovoice联系我（最好是评论区，那个我可能不看），下次我将介绍一个简单的例子来入门OMNET++。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OMNET++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OMNET++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划（DP）相关问题简单思想</title>
      <link href="/2019/09/24/hello-world/"/>
      <url>/2019/09/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>动态规划 ( Dynamic Programming, DP)是一种用来解决一类最优化问题的算法思想。 简单来说，<strong>动态规划将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得 到原问题的最优解</strong>。需要注意的是，动态规划会将每个求解过的子问题的解记录下来，这样当下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算。</p><h3 id="一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决。"><a href="#一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决。" class="headerlink" title="一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决。"></a>一个问题必须拥有<code>重叠子问题</code>和<code>最优子结构</code>，才能使用动态规划去解决。</h3><h4 id="什么是重叠子问题？"><a href="#什么是重叠子问题？" class="headerlink" title="什么是重叠子问题？"></a>什么是重叠子问题？</h4><p>比如经典的斐波那契数列，我们都知道，斐波那契数列是递归算法的一个经典练习，通常初学递归算法的时候，斐波那契数列一般是这样写：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这种写法虽然简单，但是其实做了很多无用计算，比如我们算n==5时，我们可以得到<code>F(5) = F(4) + F(3)</code>，接下来在计算F(4)时又会有<code>F(4) = F(3) + F(2)</code>。这时候如果不采取措施，<code>F(3)</code>将会被计算两次。可以推知，如果n很大，重复计算的次数将难以想象。事实上，由于没有及时保存中间计算的结果，实际复杂度会高达 O(2^n^)  , 即每次都会计算<code>F( n - 1 )</code> 和 <code>F( n - 2 )</code>这两个分支，基本不能承受n较大的情况。<br>为了避免重复计算，可以开一个一维数组<code>dp</code> ,用以保存已经计算过的结果，其中<code>dp[n]</code>记录<code>F(n)</code>的结果，并用<code>dp[n] = -1</code> 表示<code>F(n)</code>当前还没有被计算过。 </p><pre class=" language-javascript"><code class="language-javascript">int dp<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>然后就可以在递归当中判断<code>dp[n]</code>是否是-1 :如果不是-1 ，说明已经计算过<code>F(n)</code>,直接返回<code>dp[n]</code><br>就是结果；否则，按照递归式进行递归。代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//递归边界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp <span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//已经计算过，直接返回结果，不再重复计算</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">F</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">F</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计算 F(n) ,并保存至 dp[n]</span>            <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 F(n)的结果</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样就把已经计算过的内容记录了下来，于是当下次再碰到需要计算相同的内容时，就<br>能直接使用上次计算的结果，这可以省去大半无效计算，而这也是记忆化搜索这个名字的由<br>来。通过记忆化搜索，把复杂度从O( 2^n^ )降到了 O( n )。<br>像这样，在计算过程中有大量重复计算的问题，而这些问题可以用记忆化搜索来减少运算的问题，都可以说它有<strong>重复子问题</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
